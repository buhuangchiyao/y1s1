---
sidebar: auto
---
## 第一部分 C++基础语法

### 1. 预处理器

- 作用：确保头文件多次包含仍能安全工作。
- 功能： 
    1. 预处理符：`#include` 当预处理器看到`#inlcude`时，用指定头文件代替。
    2. 头文件保护符：依赖于预处理变量。
     ```cpp
       #define SALES_DATA_H     //把一个名字设定为预处理变量
       #ifdef  SALES_DATA_H     //当且仅当变量已定义时为真
       #ifndef                  //变量未定义时为真
       #endif                   //预处理结束
     ```
- 使用：
  1. 预处理无视C++语言关于作用域的规则。
  2. 一般预处理的变量名字全部大写。
  3. 头文件即使没有被包含在任何其他头文件中，也应该设置保护符。
- 预处理变量不属于命名空间std，由预处理器负责管理。
- 当用到一个预处理变量时，预处理器会自动将它替换为实际值。

### 2. 基本内置类型
- 算术类型(bool,char,short,int,long,long long,float,double,long double)。
- 带符号类型和无符号类型（unsigned）。
- 1字=4字节=32比特
  #### 类型转换（❤❤❤）
  1. 非布尔类型的算术值赋给布尔类型时：初始值为0，则结果为false；否则，结果为true。
  2. 浮点数赋值给整数类型时：仅保留小数点前的部分。
  3. 整数赋值给浮点数时：小数点后为0.
  4. 给无符号类型赋一个超出它表示范围的值时，结果是初始值对无符号类型表示数值取模后的余数。（带符号类型和未带符号类型不能混用）
  5. 赋值给带符号类型一个超出自身范围的值时，结果是未定义的。

### 3. 常量和变量
  #### 字面值常量
  - 整型和浮点字面值
    + 整型字面值：八进制（以0开头），十进制，十六进制（以0X或0x开头）。
    + 整型字面值的数据类型由值和符号决定。（数据类型为尺寸最小的那个）
    + short没有对应的字面值
    + 浮点数字面值：一个小数或以科学计数法表示的指数。指数部分用E或e标识。
  - 字符和字符串字面值
    + 字符：单引号括起来的一个字符称为char型字面值、
    + 字符串：双引号括起来的零个或多个字符。实际上是由常量字符构成的数组。
  - 转义序列
    + “翻译”一些不能直接使用的字符：
       1. 不可打印的字符，如退格或其他控制字符
       2. 有特殊含义的字符，如单引号，双引号，问号，反斜线
  - 指定字面值的数据类型
    + 通过添加前缀和后缀，可以改变整形、浮点型和字符型字面值的默认类型。
  - 布尔字面值和指针字面值
    + bool类型的字面值为：true和false
    + nullptr是指针字面值（C++❤）
    + NULL是另一个指针字面值。
       #### nullptr和NULL的区别（❤❤❤）
       1. NULL和nullptr都用来将指针初始化为字面值0来生成空指针。
       2. NULL是一个**预处理变量**，这个变量定义在头文件cstdlib中。
       3. NULL在调用时可能会出现二义性的错误。
       4. 现在的C++程序最好使用nullptr，避免使用NULL来初始化空指针。
  #### 变量
  - 什么是变量、数据类型、对象？
     1. 变量提供一个**具名的**、可供程序操作的**存储空间**;
     2. C++中的每个变量都有其**数据类型**，数据类型决定着所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算;
     3. 对象是指一块能存储数据并且具有某种类型的内存空间。
     4. “变量”和“对象”一般可以交换使用。

  - 变量的初始化与赋值（❤❤❤）
    + 初始化和赋值是两个完全不同的操作。
    + 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值。
    + 赋值是把对象的当前值擦除，而以一个新值来替代
    + 
  - 默认初始化
    + 当定义变量时没有指定初值，则变量被默认初始化。
    + 对于内置数据类型：定义于任何函数体外的变量初始化为0；定义在函数体内部的内置变量将不被初始化。
    + 对于类的对象，如果没有显式初始化，其值由类决定。
    + 一个未初始化变量（类）的值是未定义的，如果试图访问将引发错误。

  - 变量声明和变量定义（❤❤❤）
    + C++语言支持分离式编译机制：允许将程序分割为若干个文件，每个文件可被独立编译。
    + 声明：使得名字为程序所知。规定了变量的类型和名字。
    + 定义：负责创建与名字关联的实体。规定变量的类型和名字，**申请存储空间**，可能会为变量赋一个**初始值**。
    + 声明一个变量使用***extern***关键字，而且不能显示初始化。
    + 变量能且只能被定义一次，但是可以被多次声明。
  
  - 作用域
    + 全局作用域
    + 块作用域

### 4. 复合类型
  - #### 引用
    - 引用的用法
      ```cpp
      int ival = 1024;
      int &refVal = ival;       //refVal指向ival
      ```
    - 引用的含义（❤❤❤）
      - 引用并非对象（变量），它是为一个已经存在的对象所起的另一个名字（**引用即别名**）。
      - 定义引用时，程序把引用和它的初始值**绑定**在一起，而不是将初始值拷贝给引用
      - 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。
      - 引用一旦和他的初始化对象绑定在一起，就**无法重新绑定**给另外一个对象。所以引用必须初始化。
      - 引用的对象要和初始化对象的类型**严格匹配**。

  - #### 指针
    - 指针的含义
      - 指针本身是一个对象，而且是指向另外一个对象地址的复合类型。允许对指针赋值和拷贝。
      -  指针无须在定义时赋值。
    - 操作指针对象的操作符
      + 取地址符（&）：获取指针存放对象的地址。
      + 解引用符（*）：访问指针所指的对象，仅适用于指向了某个对象的有效指针。
    - 指针值的4种状态
       1. 指向一个对象
       2. 指向紧邻对象所占空间的下一个位置（尾迭代器）
       3. 空指针，没有指向任何对象
       4. 无效指针，上述情况之外的其他值
    - 空指针（不指向任何对象的指针）
       - 空指针的生成方式
       ```cpp
       int *p1=nullptr;              //C++新特性，推荐使用
       int *p2=0;                    //直接初始化为字面常量0
       int *p3 = NULL;               //预处理变量，需要#include<cstdlib>
      ```
      - 建议初始化所有的指针，对于不知道指向何处的指针，初始化为nullptr。
    - 指针的赋值：令他存放一个新的地址，从而指向一个新的对象。
     
       ***tips***：赋值永远改变的是等号左侧的对象。 
    - 指针的其他操作
      + 指针的bool值：如果指针的值为0，bool值为false；任何非0指针相应的bool值都为true。
      + 指针的相等（==）和不等（！=）操作：如果两个指针存放的**地址值**相等，则它们相等；反之不等。
      + 地址值相等包括：都为空、都指向同一对象、都指向了同一个对象的下一个地址。
    - void*指针 
      + 是一种特殊的指针类型，可用于存放任意对象的地址
      + void* 指针允许的操作：拿它和别的指针比较；作为函数的输入或输出；或者赋给另外一个void*指针。
      + 不能直接操作void*指针所指的对象。
  - #### 理解复合类型
    + 复合类型是指基于其他类型定义的类型，复合类型的声明包括**类型修饰符**和**基本数据类型**。
    + 定义多个变量的两种形式
       ```cpp
        int *p1, *p2;             //强调变量具有的复合类型
        int* p1; int* p2;         //强调本次声明定义了一种复合类型（推荐）
       ``` 
      两种形式无优劣之分，应选用一种。
    + 指向指针的指针
      - 指针是内存中的对象，在内存中拥有自己的地址。因此允许定义一个指向指针的指针(`int** p1`)；
      - 对于指向指针的指针，为了访问最原始的对象，需要对指针的指针做两次解引用。
  - #### 内置数组
     - 特点：存放类型相同的对象的容器；这些对象没有名字，通过所在位置访问；数组的大小确定不变，不能随意增加元素。
     -  定义和初始化内置数组：
        -  数组的声明：形如a[d],其中 a 是数组的名字，d 是数组的维度。 维度说明了数组中元素的个数， 元素的个数也属于数组类型的一部分。维度必须是一个常量表达式。
        -  不允许用auto关键字由初始值的列表推断数组类型。
        -  数组的的元素应为对象，因此不存在引用的数组。
        -  显示初始化数组元素：如果指明了维度，那么初始值的总数量不应该超出指定的大小； 维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化为默认值。
        -  字符数组的特殊性
          ```cpp
            char a1[]={'c','+','+'};          //列表初始化，没有空字符
            char a2[]={'c','+','+','\0'};     //列表初始化，含有显示的空字符
            char a3[]="c++";                  //自动添加表示字符串结束的空字符
            char a4[6]="Daniel";              //错误：没有空间存放空字符
          ```
        - 不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。
        - 理解复杂的数组声明
          ```cpp
            int *ptrs[10];                //ptrs是含有10个整型指针的数组
            int &refs[10];                //错误：不存在引用的指针
            //Parray是一个指针，它指向一个int数组，数组中包含10个元素
            int (*Parray)[10]=&arr;       //Parray指向一个含有10个整数的数组
            int (&arrRef)[10]=arr;        //arrRef引用一个含有10个整数的数组
            int *(&arry)[10]=ptrs;        //arry是数组的引用，该数组含有10个指针
          ```
     - 访问数组元素
       - 数组的元素能使用下标运算符和范围**for语句**访问。
       - 数组的下标为size_t类型。
       - 检查下标是否合理：下标大于等于0而且小于数组的大小。
      - 指针和数组
        - 数组名是一个指向数组首元素的指针。
        - 数组指针可以进行迭代器的所有操作。
        - 数组可以获取尾后指针，但是不能执行解引用或递增操作。
        - 数组的标准库函数begin和end
          ```cpp
          int ia[]={0,1,2,3,4,5,6,7,8,9};         //ia是一个整数数组
          int *beg=begin(ia);                     //指向ia首元素的指针
          int *end=end(ia);                       //指向ia尾元素的下一位置的指针
          ``` 
          - begin函数返回指向ia首元素的指针。
          - end函数返回指向ia尾元素下一位置的指针。
      - 数组指针运算
        - 一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置。
        - 给指针加上一个整数，得到的新指针仍需指向同一数组的其他元素，或者指向数组尾元素的下一位置。
        - 两个指针相减的结果是他们之间的距离。有可能为负。
        - 如果两个指针分别指向不相关的对象，则不能比较它们。
  - C风格字符串
    - 字符串字面值

  #### 引用和指针的区别（❤❤❤❤）
  | 指针  | 引用  |
  | ----  | ----  | 
  | 是一个对象  | 对象的一个别名  |
  | 自己的内存空间  | 和变量占用同一内存空间  |
  | 可以改变所指对象  | 初始化后不能改变  |
  | 存在空值指针  | 必须初始化  |
  | sizeof(引用) 得到所指向对象的大小  | sizeof(指针) 返回4|
  | 没有const | 有const指针 |
  - 都可以作为**函数参数**。引用的主要作用是传递函数的参数和返回值，作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；
  - 当不需要改变指向时，引用优于指针。

### 5. 流程控制语句 
  #### 简单语句
  - 空语句 
    - 定义：只含有一个单独分号的语句。
    - 表示一条逻辑上不需要，但是**语法**上需要的语句。
    - 使用空语句时应该加上**注释**。
    - 多余的空语句并不是都是无害的，不能多写分号。也不能漏写分号。
  - 块语句（复合语句）
    - 定义：用花括号括起来的语句和声明序列。
    - 表示语法上需要一条语句，但是逻辑上需要多条语句。
    - 块语句不以分号结束。
  - 语句作用域
    - 在if、switch、for语句的控制结构内定义的变量，只能在相应的语句内部可见。
    - 在控制结构内定义的变量要马上使用，所以必须初始化。
    - 如果其他代码要访问控制结构内的控制变量，则变量必须定义在语句的外部。
  #### 条件语句
  - if语句
    ```cpp
      if(condition)
        statement           //if语句
    
      if(condition)
        statement1      
      else
        statement2        //if-else语句
    ```
    - condition：必须用圆括号包围起来；可以是一个表达式，也可以是一个可以转化为bool类型的变量声明。
    - 当condition为真时执行statement语句，否则跳过。
    - if-else语句可以嵌套使用，为了避免statement语句缩进问题：在if或else之后必须写上花括号
    - else与离它最近的尚未匹配的if匹配。
  - switch语句
    ```cpp
      switch(expression){
        case  constant-expression : statement1;         //case关键字和它对应的constant-expression值一起被称为case标签
        break;                                          //break语句的作用是中断当前的控制流
        ...
        default:                                        //没有能与expression匹配的case标签是，执行default标签的statement
        statement;
        break;
      }
    ```
    - switch语句内部的控制流：
      -  如果expression和某个case标签匹配成功，程序从该标签之后的第一条语句开始执行，直到到达了switch的结尾或者是遇到一条break语句为止。
      -  想要避免执行后续case分支的代码，我们必须显示在下一个case标签前添加一条break语句。
      -  当我们希望两个或者多个case标签**共享**同一组操作时，我们故意**省略**掉break语句，使得程序连续执行若干个case标签。
    - 当省略case分支最后的break语句时，最好加一段注释说明。
    - 即使不准备在default标签下做任何工作，也应该定义一个default标签。
    - switch内部的**变量定义**
      - 如果需要为某个case分支定义并初始化一个变量，应该把变量定义在***块内***，从而确保后面的case标签都在变量的**作用域之外**。
  #### 迭代语句（循环语句）
  - while语句
    ```cpp
     while(condition)
        statement           //只要condition的求值结果为真就一直执行statement。
    ``` 
    - 定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程。
    - 使用：当不确定**迭代次数**时，使用while循环比较合适。
  - for语句
    ```cpp
    for(init-statement;condition;expression)    //init-statement负责初始化一个值
                                                //condition作为循环控制的条件，只要condtion为真，就执行一次statement
                                                //expression负责修改init-statement的值
      statement
    ```
    - init-statement必须是声明语句、表达式语句或者空语句的一种。
    - for语句头中定义的对象只在for循环体内可见
    - for语句能省略init-statement,condition,expression中的任何一个，但是分号必须保留。
  - 范围for
    - 作用：遍历容器或其他序列的所有元素。
    ```cpp
      for( declaration : expression )       //expression是一个序列，且都拥有能返回迭代器的begin和end成员。
                                            //declaration定义一个序列中元素类型的变量。（常使用auto类型转换符）
        statement ;                         //迭代语句块
    ```
    - 范围for只能对序列进行迭代，不能通过statement在序列中添加（删除）元素。
    - 例：
      ```cpp
        vector<int> v={0,1,2,3,4,5,6};        //定义一个vector<int>变量

        for(auto &r: v)                       //使用pass by reference进行写操作
            r*=2;
        ``` 
  - do while语句
    ```cpp
      //do while循环先执行循环体，后检查条件
      do
        statement
      while(condition);         //分号表示语句结束
    ``` 
    - 因为do while语句先执行语句块，后检查条件，所以不允许在条件部分定义变量。
  #### 跳转语句
  - break语句：负责终止离它最近的while、do while、for或switch语句，并从这些语句后的第一条语句开始继续执行。（跳出语句块）
  - continue语句：终止最近的循环中的当前迭代并立即开始下一次迭代。
    - 对于while或者do while语句来说，继续判断条件的值
    - 对于传统for循环来说，继续执行for语句头的expression
    - 对于范围for来说，用序列中的下一个元素初始化循环控制变量

### 6. 运算符
  - c++运算符基础
    > 1. 重载运算符：自定义运算符的含义，为已知运算符赋予另外一层含义。
    > 2. 括号无视优先级与结合律
    > 3. 在表达式求指的过程中，运算对象常常会由一种类型转换成另外一种类型。
    > 4. 左值和右值运算符
  - 算术运算符
    - |运算符|功能|
      |----|----|
      |+|一元正号|
      |-|一员负号|
      |*|乘法|
      |/|除法|
      |%|求余|
      |+|加法|
      |-|减法|
    - 算术运算符都满足左结合律。
    - 一元正号和一元负号运算符，返回运算对象的副本。
    - 参加取余运算的运算对象必须是整数类型。

  - 逻辑和关系运算符
    - 逻辑运算符
      |运算符|功能|
      |----|----|
      |！|逻辑非|
      |&&|逻辑与|
      |\|\||逻辑或| 
      + 逻辑或（||）和逻辑与（&&）都是左结合律的运算符，先求左侧运算对象的值再求右侧运算对象的值。
      + 逻辑或和逻辑与是**短路求值**的运算符
      + 逻辑非(!):将运算对象的值取反后返回。
    + 关系运算符
      |运算符|功能|
      |----|----|
      |<|小于|
      |<=|小于等于|
      |>|大于|
      |>=|大于等于|
      |==|相等|
      |!=|不相等| 
      + 进行比较运算时除非比较的对象是bool类型，非则不要使用bool类型的字面值作为运算对象。
  - 赋值运算符(=)
    - 赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分应加上括号。
    - 切勿混淆相等运算符（==）和赋值运算符
    - 复合赋值运算符：使用复合赋值运算符只求值一次，而普通的运算符求值两次。
  - 递增和递减运算符
    - 递增（++）和递减（--）运算符为对象加1和减1提供了一种简洁的书写形式。
    - 递增（++）和递减（--）运算符都有**前置**和**后置**两种版本。
    - 除非必须，否则不用递增递减运算符的后置版本。
  - 成员访问运算符
    ``` cpp
      ptr->mem;
      (*ptr).mem;     //这两种形式等价
    ```
    - 解引用运算符的优先级低于点运算符。
    - 箭头运算符作用于一个指针类型的运算对象，结果是一个左值。
  - 条件运算符
    ``` cpp
      cond ? expr1 : expr2 ;
    ```
    - cond是判断条件的表达式，expr1和expr2是两个类型相同或可能转换位某个公共类型的表达式。
    - 允许条件运算符的内部嵌套另外一个条件运算符。
    - 条件运算符优先级非常低，cond一般加括号。
  - 位运算符（❤❤❤）
    - 作用：用于整型类型的运算对象，并把运算对象看成是二进制位的集合。
      |  运算符 | 功能  | 操作  |
      |----|----|----|
      | ~|位求反| 逐位求反后生成一个新值|
      | <<|左移|在右侧插入值为0的二进制位|
      | >>|右移| |
      | &|位与|两个运算对象对应位都是1，则该位为1|
      | \||位或|两个运算对象对应位至少有一个1，则运算结果为1|
      | ^|位异或|两个运算对象对应位不相同时，运算结果为1|
  - sizeof运算符（❤❤❤❤）
    - 返回一条表达式或者一个类型名字所占的**字节数**。
    - 返回的值是**size_t类型**的
    - sizeof运算符的两种形式
      ```cpp
        sizeof (type);
        sizeof expr;        //返回的是表达式结果类型的大小
      ``` 
    - sizeof运算符的结果
       1. 对char或者类型为char的表达式执行sizeof运算，结果得1。
       2. 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
       3. 对指针执行sizeof运算，得到指针本身所占的空间的大小（4）。
       4. 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。
       5. 对数组执行sizeof得到整个数组所占空间的大小。等价于对数组中所有的元素各执行一次sizeof的和。
       6. 对string对象和vector对象执行sizeof运算只返回该类型固定部分的大小，不计算对象中的元素占用了多少空间。
    - sizeof不会实际求对象的值，所以可以计算无效指针的大小。
  ### 7. const限定符
  - #### const的作用(❤❤❤❤)
 1. 定义常量   
    - 由oonst限定符修饰的对象是一个常量，不能对其进行赋值操作。
    - const对象必须初始化。
    - 格式：`const int bufSize = 1 ;    //初始值可以是任何复杂的表达式或函 数`
 2. 类型检查

     **`#define`常量和`const常量`的区别**：
     + `const常量`具有**类型**，编译器可以进行安全检查；
     + `#define`定义没有数据类型，只是简单的字符串替换，不能进行安全检查。
     + const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像 #define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝。
 3. 防止修改，增加安全性
   const变量不能被修改
   ```cpp
     void f(const int i){
       i++; //error!
     }
   ```
 4. 可以节省空间，避免不必要的内存分配

     `const常量`比`#define常量`占用的内存小。

  - 默认状态下，const对象仅在文件内有效
    - 如果程序包含多个文件，则每个用了const对象的文件都必须有该const定义。
    - 默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定了独立的变量。
    - 使用`extern`关键字定义的const变量只需定义一次就可以了。
    - 如果想在多个文件之间共享使用`const`变量，必须在变量的定义之前添加extern关键字。
  - const的引用
    ```cpp
      int i = 42;
      const int &r = i;         //允许将const int&绑定到一个普通的int对象上
      const int ci = 1024;          //定义一个const常量
      const int &rl = ci;           //正确：引用及其对应的对象都是常量
      rl = 42;                      //错误：rl是对常量的引用，不能修改它绑定的值
      int &r2 = ci;                 //错误：不能用非常量引用指向一个常量对象
    ``` 
    - 对const的引用可能引用一个非const的对象
    - 对const的引用绑定的变量的值不能修改。
  - #### 指针和const（❤❤❤❤）
  - const和指针的四种位置关系
    ```cpp
      const char * a;         //指向const对象的指针或者说指向常量的指针。
      char const * a;         //等价与上面的形式
      char * const a;         //const指针、常量指针。
      const char * const a;   //指向const对象的const指针。          
    ```
    - const出现在*左边，表示被指的对象是常量，值不可以改变；
    - const出现在*右边，表示指针自身是常量，指针地址不可以改变
    - const出现在*两边，所指对象和指针本身都是常量，值和地址都不可以改变。
  - 顶层const和底层const（★★★）
    - 顶层const：表示指针本身是一个常量。
    - 底层const：表示指针所指的对象是一个常量。
  - constexpr和常量表达式
    - 常量表达式：是指值不会改变并且在编译过程就能得到计算结果的表达式。
    - constexp变量：C++11新标准规定，允许将变量声明为constexpr类型以便由**编译器**来验证变量的值是否是一个常量表达式。
    - 一个**constexpr指针**的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。
    - constexpr既可以指向常量也可以指向一个非常量。
    - constexpr把它所定义的指针置为了顶层const，不能改变所指地址。
  ### 8.函数
  - 函数基础
    - 组成:返回类型、函数姓名、参数列表、函数体。
    - 函数的调用：
      - 通过**调用运算符**()来执行函数。
      - 运算符之内是一个用逗号隔开的**实参列表**。
      - 调用表达式的类型就是函数的**返回类型**。
    - 函数调用的过程：
       - 实参初始化函数对应的形参；
       - **主调函数**暂停执行，**被调函数**开始执行。
       - 完成被调函数，遇到**return**语句时函数结束执行。
    - return语句的作用：
      - 返回return语句中的值；
      - 将程序控制权从被调函数转回主调函数。
    - 实参是形参的初始值。所以实参的类型必须与对应的形参类型匹配。
    - 函数的形参列表可以为空，但是不能省略。可以使用void表示函数没有形参；任意两个形参不能同名。
    - 不返回任何值的函数返回类型为void。
  - C++语言中，名字有**作用域**，对象有**生命周期**
    - 名字的作用域是程序文本的一部分，名字在其中可见。
    - 对象的生命周期是程序执行过程中该对象存在的一段时间。
    - **局部变量**：形参和函数体内部定义的变量统称为**局部变量**。仅在函数的作用域内可见，函数终止时，形参也会被销毁。
    - **自动对象**：只存在于块执行的对象称为自动对象。
    - **局部静态变量**：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。将局部变量定义为static类型。
  - 函数声明
    - 函数声明和函数的定义非常类似，唯一的区别是函数声明无须函数体。
    - 函数声明（函数原型）包括：返回类型、函数名、形参类型。
  - #### 函数的参数传递
    - 每次调用函数都会**重新创建**它的形参，并用传入的实参初始化。
    - 形参初始化的机理和变量初始化一样：
      - pass by reference:如果形参是引用类型，它将绑定到对应的实参上。
      - pass by value:将实参的值拷贝后赋给形参。
      - 指针形参：当执行指针拷贝操作时，拷贝的是指针的值。
    - 传引用参数
      - 使用引用形参，允许函数一个或多个实参的值。  
      - 当某些类型不支持拷贝操作或者拷贝大的类对象或者容器对象时，函数只能通过引用形参来访问该对象。
      - 对于无须改变对象内容的形参，定义为对常量的引用。
      - 建议使用引用类型的形参代替指针。
    - 数组形参
      - 数组的两个性质：不允许拷贝数组；数组名是一个指向数组第一个元素的指针。
      - 不能拷贝数组，所有不能对数组进行pass by value
      - 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针
      ```cpp
        //三个print函数是等价的
        //每个函数都有一个const int*类型的形参
        void print(const int*);
        void print(const int[]);
        void print(const int[10]);
      ``` 
      - 当函数不需要对数组元素进行写操作时，数组形参应该是指向const的指针
      - 数组引用：
      ```cpp
        int &arr[10];           //arr为含有10个int引用的数组
        int (&arr)[10];         //arr为具有10个整数的整型数组的引用，其中维度是类型的一部分
      ``` 
  - 返回类型和return语句
    - return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。
    - return语句的两种形式：
    ```cpp
      return ;
      return expression;
    ```
    - 无返回值函数：没有返回值的return语句只能用在返回类型是void的函数中。这类函数中return可以省略，会隐式地执行return。
    - 无返回值的函数可以返回另一个返回void的函数。`void()-->void()-->return`
    - 有返回值的函数，return语句返回值必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。
    - 如果函数返回引用，则该引用仅是它所引对象的一个别名。
    ``` cpp
      const string &shorterString(const string &s1,const string &s2)
      {
        return s1.size() <= s2.size() ? s1 : s2 ;
      }
    ```
    - **不要返回局部对象的引用或指针**：函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不在有效的内存区域。
    - 函数可以返回类类型。
    - `C++11`函数可以返回花括号包围的值的列表。如果函数返回内置类型，最多包含一个值，且该值所占空间不大于目标类型的空间；函数返回类类型时，由类本身定义初始值如何使用。
    - **主函数main的返回值**
      - 主函数可以没有return语句直接结束，编译器会隐式的插入一条返回0的return语句。
      - 返回0表示执行成功，返回其他值表示执行失败，非0的含义由机器决定。
      - cstdlib头文件定义了两个预处理变量，分别表示成功与失败。（`EXIT_SUCCESS`,`EXIT_FAILURE`)
      - main函数不能调用它自己。
    - 递归：一个函数调用它自己，不管这种调用是直接的还是间接的。
    - **返回数组指针：**
      - 因为数组不能被拷贝，所以函数不能返回数组。但是，函数可以返回数组的指针或者引用。可以使用类型别名简化返回数组指针或引用的操作。
      - 声明一个返回数组指针的函数
        - 格式
        ```cpp
          Type (*functionname(parameter_list))[dimension]
          //Type表示元素的类型，dimension表示数组的维度
          //parameter_list表示形参列表
          //（*functionname(parameter_list))两端的括号必须存在，否则表示返回指针的数组。

          int (*func(int i))[10];
          //返回一个指向大小为10的int数组的指针。
        ``` 
      - 使用尾置返回类型
      ```cpp
        //func接受一个int类型的参数，返回一个指针，该指针指向含有10个整数的数组
        auto func(int i) -> int(*)[10];
      ```
      - 使用decltype：如果我们知道函数返回的指针将指向那个数组，就可以使用decltype关键字声明返回类型。`decltype(array) *function(parameter_list)`
      - decltype并不负责把指针转换成对应的指针，所以decltype的结果是个数组。
  - #### 函数重载
    - 同一作用域内的几个函数的名字相同但是形参列表不同，我们称之为重载函数。
    - main函数不能重载。
    - 定义重载函数：
      - 对于重载函数，他们应该在形参数量或形参类型上有所不同。
      - 不允许两个函数除了返回类型外其他所有的要素都相同。
    - 重载和const形参
      - 一个拥有顶层const(所指对象地址不变）的形参无法和另一个没有顶层const的形参区分开来。
      - 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层(所指对象值不变）的。
    - const_cast和重载
      - const_cast将常量对象转换成非常量对象
    - 调用重载的函数
      - 函数匹配：把函数调用与一组重载函数中的某一个关联起来
      - 调用重载函数的三种可能：
        - 编译器找到一个与实参**最佳匹配**的参数。
        - 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配**的错误。
        - 有多于一个函数可以匹配，但每一个都不是明显的最佳选择，称为**二义性调用**。
    - 重载与作用域：一旦在当前作用域找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。C++语言中，名字查找发生在类型检查之前。
  - 三种函数相关的语言特性
    - **默认参数**
      - 在函数定义过程中，我们可以为形参提供默认实参。默认实参作为形参的初始值出现在形参列表中。我们可以为一个或多个形参定义默认值，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。
      - 如果想使用默认实参，只要在调用函数的使用省略该实参就可以了。
      - 当设计含有默认实参的函数时，要合理设置形参的顺序，尽量把不怎么使用默认值的形参出现在前面，而让经常使用默认值的形参出现在后面。
      - 函数的后续声明只能为之前没有默认值的形参添加默认参数，而且该形参右边的所有形参必须都有默认值。不能修改一个已经存在的默认值。
      - 局部变量不能作为默认实参。
    - **内联函数（inline）**
      - 将函数声明为`inline`只是向编译器发出的请求，编译器可以选择忽略这个请求。
      - 内联机制用于优化规模较小、流程直接、频繁调用的函数。
    - **constexpr函数**
      - constexpr函数是指能用于常量表达式的函数
      - 特点：函数的返回类型及所有参数的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。
      - constexpr函数被隐式地指定为内联函数。
      - constexpr函数不一定返回常量表达式。
    - 内联函数和constexpr函数通常定义在头文件中。
  - 函数指针
    - 函数指针指向的是函数而非对象。函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定。
    ```cpp
    //一个比较两个string对象的指针
    bool lengthCompare(const string &, const string &) ;
    //指向lengthCompare函数的指针
    bool (*pf)(const string &,const string &);
    //*pf两端的括号必不可少，否则pf是一个返回值为bool指针的函数
    ```
    - 使用函数指针
      - 当我们把函数名作为一个值使用时，该函数自动地转换成指针。
      - 我们能直接使用指向函数的指针调用该函数，无须提前解引用指针。
    - 函数指针形参
      - 不能定义函数类型的形参，但是形参可以是指向函数的指针。
      - 我们可以直接把函数作为实参使用，此时它会自动转换为指针。
      - 类型别名和decltype可以简化使用了函数指针的代码。
    - 返回指向函数的指针
      - 虽然不能返回一个函数，但是能返回指向函数类型的指针。
      - 和返回数组指针相似，可以使用尾置返回类型的方式，声明一个返回函数指针的函数体。
    ```cpp
      //使用类型别名声明 返回指向函数的指针
      using PF = int (*) (int *,int);       //PF是指针类型
      PF f1(int);         //PF是指向函数的指针，f1返回指向函数的指针
      //直接声明
      int (*f1(int))(int *,int);
      //尾置声明
      auto f1(int)->int(*)(int *,int);
    ``` 
    - 将auto和decltype用于函数指针类型
      - 明确直到返回的函数是哪一个，就能使用`decltype`简化书写函数指针返回类型的过程，
      ```cpp
        string::size_type sumLength(const string&,const string&);
        string::size_type largeLength(const string&,const string&);
        //根据其形参的取值，getFcn函数返回指向sumLength或者largeLength的指针。
        decltype(sumLength) *getFcn(const string &);
      ```
    - decltype作用于某个函数时，它返回函数类型而非指针类型。因此，我们显示地加上*以表明我们需要返回指针，而非函数本身。
  